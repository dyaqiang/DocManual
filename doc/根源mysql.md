#### 1、重新理解mysql

##### 1.1 客户端、服务端

>```
>MySQL`服务器进程的默认名称为`mysqld`， 而我们常用的`MySQL`客户端进程的默认名称为`mysql
>```

##### 1.2 启动客户端、服务端

##### 1.3 客户端和服务端建立连接

> 通信方式一：TCP|IP

* TCP|IP
* 端口号：mysqld -P3307
* 连接：mysql -h127.0.0.1 -uroot -P3307 -p

> 通信方式二：Unix域套接字文件

* 连接：mysql -hlocalhost -uroot --socket=/tmp/a.txt -p

##### 1.4 服务器处理客户端请求流程

> 流程图：客户端->处理连接->查询缓存->语法解析->查询优化->存储引擎->文件系统

###### 1.4.1 连接管理

连接包含三种类型：TCP/IP 、命名管道共享内存、Unix套接字

> *认证：携带主机信息、用户名、密码 到服务端进行认证*

> *交互：客户端选择一种连接方式建立连接，客户端进程连接到服务端进程的时候，服务端的进程会建立一个线程，来处理该连接的交互行为，当客户端断开的时候并不会理解销毁这个线程，而是把他缓存起来等待其他的客户端的连接，一旦建立了连接服务端会一直监听客户端的请求，获取到的消息是一个文本，进入下一步的解析*

> *安全：s s l*

###### 1.4.2 解析和优化

包含三部分：查询缓存、语法解析、查询优化

* 查询缓存

  > *缓存：之前查询过就不再进行查询，直接命中缓存返回结果*
  >
  > *不缓存：查询语句的符号一点不一样也不会走缓存、系统函数一般不走缓存、有修改表结构的不走缓存（update 、insert）*
  >
  > *删除：从 MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除*

* 语法解析

  > *对客户端发送的文本进行解析，满足服务端可识别的程序，可以简单理解为编译*

* 查询优化

  > 我们写的sql 并不是最好的查询效果，用那些索引，怎么连接等、这个时候会进行优化生成一个==执行计划==，我们可以用==explain==查看这个执行计划

###### 1.4.3 存储引擎

 *前面的操作还咩有操作到真实的数据呢，如何把数据存储到物理层，和从物理层提取数据， 这个事情就是存储引擎负责的，他会提供一个底层的API供上层调用 （行数据还是我们看到的表现层的逻辑）*

##### 1.5 存储引擎

###### 常见的存储引擎

1. InnoDB
2. MyISAM
3. MEMORY

###### 常用操作

```mysql
SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)

#suport 是否支持
#comment 注释
#Transactions 是否支持事物
#XA 是否支持分布式事务
#Savepoints 是否支持事物回滚
```

###### 创建表时创建不同的存储引擎

```mysql
#创建存储引擎
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;

#修改存储引擎
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```



#### 2、启动选项和配置文件

*阐述：mysql 的客户端和服务端程序有很多的配置项，服务端如：和客户端的连接数、和客户端的通信方式、表的存储引擎。 客户端如：host 、端口号、用户名、密码*

> 配置中总会有些默认值、连接数默认151、存储引擎默认innodb

##### 2.1启动项的命令行的常见命令配置：

| 长形式       | 短形式 | 含义     |
| ------------ | ------ | -------- |
| `--host`     | `-h`   | 主机名   |
| `--user`     | `-u`   | 用户名   |
| `--password` | `-p`   | 密码     |
| `--port`     | `-P`   | 端口     |
| `--version`  | `-V`   | 版本信息 |

##### 2.2配置文件的配置

###### 2.21 配置文件的路径

###### 2.22 配置文件的内容

###### 2.22 配置文件的配置优先级

##### 2.3 系统变量

*会影响程序运行的一些变量，系统变量==VARIABLES==*

```mysql
#查看默认存储引擎值
SHOW VARIABLES LIKE 'default_storage_engine';
#查询容许客户端最大连接数值
SHOW VARIABLES like 'max_connections';
#查询defalut开头的系统变量值
SHOW VARIABLES LIKE 'default%';
```

###### 2.3.1 设置系统变量

*1、命令行启动选项中 2、配置文件中  3、服务器运行过程中也可以配置  4、系统变量也可以设置作用范围*

##### 2.4 状态变量

*为了了解服务的运行状态，服务器会自己设置一些状态变量==STATUS==，*

```mysql
SHOW STATUS LIKE 'thread%';
# Threads_connected :当前有多少客户端和服务端连接
# Handler_update 更新了多少条记录了
```



#### 3、字符集、比较规则

> ***字符集简介****：计算机只能识别二进制、那么我们的数据怎么存储到计算机，需要解决两个事情：1、那些数据映射成二进制，就是一个字典查看，2、怎么映射：当然是编码和解码*。
>
> ***比较规则****：怎么比较大小？全部转换为二进制进行比较，大小写怎么办？单独处理呗，怎么处理就会有什么样的比较效果*
>
> ***常见的编码方式：*** *ASCII、ISO 8859-1、GB2312、GBK、utf8*

##### 3.1 mysql中的字符集和比较规则

> *utf8mb3: 阉割过的utf8字符集，只使用1～3个字节表示字符（在MySQL中utf8是utf8mb3的别名）*
>
> *utf8mb4：正宗的utf8字符集，使用1～4个字节表示字符*
>
> *所以在使用emoji 表情的时候 我们必须选择utf8mb4，不能直接使用utf8 🐴* 

###### 3.1.1 字符集比较规则

```mysql
#查看支持的字符集--CHARSET
SHOW CHARSET;
#查看比较规则--COLLATION
SHOW COLLATION LIKE 'utf8\_%';
#utf8 默认的比较规则：utf8_general_ci
```

##### 3.2 字符集比较规则的应用

*有级别的概念：服务器、数据库、表级别、列级别*

###### 3.2.1 服务器

```mysql
#字符集
SHOW VARIABLES LIKE 'character_set_server';
#比较规则
SHOW VARIABLES LIKE 'collation_server';
#服务器级别默认的字符集是utf8，默认的比较规则是utf8_general_ci。

#启动创建时配置
[server]
character_set_server=gbk
collation_server=gbk_chinese_ci
```

###### 3.2.1 数据库

```mysql
#数据库级别的设置
mysql> CREATE DATABASE charset_demo_db
    -> CHARACTER SET gb2312
    -> COLLATE gb2312_chinese_ci;
#字符集    
SHOW VARIABLES LIKE 'character_set_database';    
#比较规则
SHOW VARIABLES LIKE 'collation_database';
```

###### 3.2.3 表级别

```mysql
#表级别设置设置
mysql> CREATE TABLE t(
    ->     col VARCHAR(10)
    -> ) CHARACTER SET utf8 COLLATE utf8_general_ci;
```

###### 3.2.3 列级别

```mysql
CREATE TABLE 表名(
    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
    其他列...
);
ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
#一般是默认的
```

##### 3.3 客户端服务端通信时的字符集

*当客户端的编码字符集和服务端的解码字符集不一致的时候怎么办呢？*

###### 3.3.1 字符集转换

> 客户端：发送请求使用的字符集.   ( linux: utf8、 win：gbk. 软件navicat、phpstrom 会自定义字符集)
>
> 服务端：接受解码，认为来的是character_set_client的字符 ： 会进行编码为character_set_connection的字符
>
> 数据库查找：character_set_connection这个编码的字符进行查找这种编码的列。
>
> 返回：character_set_results这个列编码的方式进行返回。
>
> 客户端使用的是： character_set_results编码的方式，就能读懂了

*通常都把 ***character_set_client*** 、***character_set_connection***、***character_set_results*** 这三个系统变量设置成和客户端使用的字符集一致的情况，这样减少了很多无谓的字符集转换

###### 3.3.2 比较规则



#### 4、Innodb   记录行结构

*疑惑：客户端发送请求服务端返回结果，表的数据存在哪里？什么格式存放？怎么访问这些数据？*

##### 4.1 Innodb 页

>  *1、我们把数据存储在磁盘上的时候是用存储引擎，断电后还存在*。  *2、处理数据是在内存中进行的，所以处理的时候需要先加载数据进内存*。  *3、我们知道内存处理比加载进内存要快几个数量级，每次操作数据都加载所有数据进入内存的话，那么十分影响效率*。 *4、所以进行以页为单位进行内存加载*。 *5、Innodb 每次内存加载是16kb,内存数据刷到磁盘也是16kb*。

##### 4.2 Innodb 行

*记录在磁盘上的存储方式就是行记录-行格式*

###### COMPACT行格式

* 额外信息

  1. 变长字段长度列表

     记录那些varchar的字段具体占用的长度是多少，即真正的长度和占用的字节数

  2. NULL值列表

  3. 记录头信息

* 真实数据

  1. 我们自己定义的列
  2. 隐藏列 row_id、transaction_id、roll_pointer

  

  

  

#### 5 、Innodb  数据页结构

*页简介：管理存储空间的基本单位，一个页的大小是16kb ，有不同类型的页：1、表空间头信息的页，2、Insert Buffer信息的页 2、INODE信息的页 3、undo日志信息的页 4、存放表中记录的页 index页*



##### 5.1 数据页结构

| 名称                 | 中文名             | 占用空间大小 | 简单描述                 |
| -------------------- | ------------------ | ------------ | ------------------------ |
| `File Header`        | 文件头部           | `38`字节     | 页的一些通用信息         |
| `Page Header`        | 页面头部           | `56`字节     | 数据页专有的一些信息     |
| `Infimum + Supremum` | 最小记录和最大记录 | `26`字节     | 两个虚拟的行记录         |
| `User Records`       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| `Free Space`         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| `Page Directory`     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| `File Trailer`       | 文件尾部           | `8`字节      | 校验页是否完整           |

##### 5.2 记录在页中的存储

*总体过程：新增记录从Free Space 替换空间为User Records 部分*

###### 5.2.1 记录头信息的秘密

| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| `预留位1`      | `1`               | 没有使用                                                     |
| `预留位2`      | `1`               | 没有使用                                                     |
| `delete_mask`  | `1`               | 标记该记录是否被删除                                         |
| `min_rec_mask` | `1`               | B+树的每层非叶子节点中的最小记录都会添加该标记               |
| `n_owned`      | `4`               | 表示当前记录拥有的记录数                                     |
| `heap_no`      | `13`              | 表示当前记录在记录堆的位置信息                               |
| `record_type`  | `3`               | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  | `16`              | 表示下一条记录的相对位置                                     |

*delete_mask：当前记录是否被删除，真实数据不会被删除，只是打了个标记，当新的数据来的时候覆盖就行了*

*min_rec_mask：非叶子结点的最小记录*

*heap_no ：数据所在的位置*

*record_type：记录叶子上的类型*

*next_record：真实数据到下一条真实数据的偏移量*

##### 5.3 页目录

*平时我们查找数据的时候是遍历但是也太慢了，所以大师们发明了目录*

##### 5.4 页面头部

| 名称                | 占用空间大小 | 描述                                                         |
| ------------------- | ------------ | ------------------------------------------------------------ |
| `PAGE_N_DIR_SLOTS`  | `2`字节      | 在页目录中的槽数量                                           |
| `PAGE_HEAP_TOP`     | `2`字节      | 还未使用的空间最小地址，也就是说从该地址之后就是`Free Space` |
| `PAGE_N_HEAP`       | `2`字节      | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录） |
| `PAGE_FREE`         | `2`字节      | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| `PAGE_GARBAGE`      | `2`字节      | 已删除记录占用的字节数                                       |
| `PAGE_LAST_INSERT`  | `2`字节      | 最后插入记录的位置                                           |
| `PAGE_DIRECTION`    | `2`字节      | 记录插入的方向                                               |
| `PAGE_N_DIRECTION`  | `2`字节      | 一个方向连续插入的记录数量                                   |
| `PAGE_N_RECS`       | `2`字节      | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录） |
| `PAGE_MAX_TRX_ID`   | `8`字节      | 修改当前页的最大事务ID，该值仅在二级索引中定义               |
| `PAGE_LEVEL`        | `2`字节      | 当前页在B+树中所处的层级                                     |
| `PAGE_INDEX_ID`     | `8`字节      | 索引ID，表示当前页属于哪个索引                               |
| `PAGE_BTR_SEG_LEAF` | `10`字节     | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| `PAGE_BTR_SEG_TOP`  | `10`字节     | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |

##### 5.5 文件头部

| 名称                               | 占用空间大小 | 描述                                                         |
| ---------------------------------- | ------------ | ------------------------------------------------------------ |
| `FIL_PAGE_SPACE_OR_CHKSUM`         | `4`字节      | 页的校验和（checksum值）                                     |
| `FIL_PAGE_OFFSET`                  | `4`字节      | 页号                                                         |
| `FIL_PAGE_PREV`                    | `4`字节      | 上一个页的页号                                               |
| `FIL_PAGE_NEXT`                    | `4`字节      | 下一个页的页号                                               |
| `FIL_PAGE_LSN`                     | `8`字节      | 页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
| `FIL_PAGE_TYPE`                    | `2`字节      | 该页的类型                                                   |
| `FIL_PAGE_FILE_FLUSH_LSN`          | `8`字节      | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | `4`字节      | 页属于哪个表空间                                             |

##### 5.6 File Trailer

*InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以`页`为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况）*

##### 5.7 总结

1. InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做`数据页`。
2. 一个数据页可以被大致划分为7个部分，分别是
   - `File Header`，表示页的一些通用信息，占固定的38字节。
   - `Page Header`，表示数据页专有的一些信息，占固定的56个字节。
   - `Infimum + Supremum`，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的`26`个字节。
   - `User Records`：真实存储我们插入的记录的部分，大小不固定。
   - `Free Space`：页中尚未使用的部分，大小不确定。
   - `Page Directory`：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
   - `File Trailer`：用于检验页是否完整的部分，占用固定的8个字节。
3. 每个记录的头信息中都有一个`next_record`属性，从而使页中的所有记录串联成一个`单链表`。
4. `InnoDB`会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：
   - 通过二分法确定该记录所在的槽。
   - 通过记录的next_record属性遍历该槽所在的组中的各个记录。
5. 每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。
6. 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的`LSN`值，如果首部和尾部的校验和和`LSN`值校验不成功的话，就说明同步过程出现了问题。



#### 6、B+树索引

> *1、INNODB数据页由 7个组成部分*
>
> *2、各个数据页组成一个双向的数据链表*
>
> *3、每个数据页记录按照主键从小到大组成单向列表*
>
> *4、每个数据页都会为存储在里面的记录生成数据目录（槽）*
>
> *5、通过主键查找记录的时候在目录中通过二分法定位槽所在位置进行遍历*
>
> 脑子里想下那个图

#####  6.1 没有索引的查找

###### 6.1.1 在一个页中查找

*主键搜索：二分法查找槽即可*

*非主键搜索：从小到大遍历*

###### 6.1.2 在很多页中查找

*先定位页，再从页中查找响应记录*

##### 6.2 索引

###### 6.2.1 简单方案索引

*每个页主键从小到大，页面按照从小到大排列，页的两个值。页号+最小主键值*

###### 6.2.2 Innodb方案

- `0`：普通的用户记录
- `1`：目录项记录  只有主键值和页的编码两列
- `2`：最小记录
- `3`：最大记录

*INNODB 查找数据的过程是这个样子的：定位目录项记录->定位目录项纪录->定位目录项纪录········->普通的用户记录*

> 概念转换
>
> 数据页：节点
>
> 目录项纪录页：非叶子节点
>
> 用户纪录页：叶子节点

*这个时候我们就可以讨论下查询速度和存储量级了* 

> - 第0层放的是用户纪录
> - 如果`B+`树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放`100`条记录。
> - 如果`B+`树有2层，最多能存放`1000×100=100000`条记录。
> - 如果`B+`树有3层，最多能存放`1000×1000×100=100000000`条记录。
> - 如果`B+`树有4层，最多能存放`1000×1000×1000×100=100000000000`条记录。
> - 数据量级很大了，再想下二分法查找方案是不是很快。nice

##### 6.3 聚簇索引

*包含两种特性：1、主键从小到大排列。2、叶子节点包含完整的用户纪录（默认创建的索引）*

##### 6.4 二级索引（辅助索引）

*包含两种特性：1、按照某列从小到大排列。2、叶子节点存储的是某列和主键  3、所以查找的时候需要根据主键再去聚簇索引中查找一次。这个过程叫==回表==（为什么回表，节省空间）*

##### 6.5 联合索引

*目录项页会纪录 两列+主键*

##### 6.6 注意

###### 根页面一旦建立 不会改变

###### 内节点中目录项节点唯一

###### 一个页面最少存储两条纪录

##### 6.7 Myisam 的索引

> *1、索引和数据是分开的*
>
> *2、通过行号直接添加就行了*
>
> *3、主键+行号的方式查找*
>
> *4、myisam 每次都要回表*



#### 7、B+ 索引的使用

> *B + 树有很多层，叶子节点，根干节点，叶子节点存储用户纪录、根干节点存储目录项纪录*
>
> *INNODB 自动创建聚簇索引*
>
> *二级索引 叶子节点包含列+主键，查找用户纪录 需要一次回表到聚簇索引中查找*
>
> *每层节点从小到大排列，联合索引前面的列先排，一样的情况下，才会按照后面的列排序*



##### 7.1 索引的代价

1、空间代价：特性知，建立一个索引是很大的空间

2、时间代价：增删该的时候大量索引会重建



##### 7.2 适用条件

